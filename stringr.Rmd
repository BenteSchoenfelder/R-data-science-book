# Character data: stringr {#stringr}

Resources:

- [Homepage](https://stringr.tidyverse.org/)
- [Book Chapter in R4DS](https://r4ds.had.co.nz/strings.html)
- [Cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/strings.pdf)
- [Vignette Into](https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html)
- [Vignette Regular Expressions](https://cran.r-project.org/web/packages/stringr/vignettes/regular-expressions.html)

Suggested data: recipes

Advice: Many of the examples in the Vignettes just refer to vectors. How can we use stringr to create/modify character columns of a data frame?




```{r, include=FALSE, results='hide'}
#Loading of the libraries
#install.packages("stringr")
#install.packages("gutenbergr")
#install.packages("tidytext")

#Keep in mind that knitr doesn't work, if those are not commented out. The packages are necessary to run the script nonetheless.

library(readr)
library(stringr)
library(dplyr)
library(gutenbergr)
library(tidytext)

#---------------------------------------------------

#Loading of a fulltext example. The time machine from H.G. Wells from the Gutenberg Project.

#//The website of

tm_text <- gutenberg_download(35)


#Loading and formatting of the data set

recipes <- read_csv("data/recipes.csv")

str(recipes)

   #//[!!!]It might make sense to have two versions of the database. One, where most columns just contain strings, and another version, where every column has the appropriate data type. One could make use of the stringr methods e.g. on the dates if they're not in date format, but in character format.

recipes.c <- recipes

#//[!!!] Instead of doing everything manually, maybe reimport via read.r
    

#The ids of the recipe and of the contributor are de facto factors.

recipes.c$id <- as.factor(recipes$id)
#check str(recipes$id)

recipes.c$contributor_id <- as.factor(recipes$contributor_id)
#check str(recipes$contributor_id)

# The nutrition values are num

recipes_test <- str_sub(recipes.c$nutrition[1], 2, str_length(recipes.c$nutrition[1])-1)
recipes_test <- strsplit(recipes$nutrition[1], ", ")
recipes_test_1 <- as.numeric(recipes_test[[1]])



```

--Optionale Inhalte:
Vergleich von stringR mit base R. Inwiefern ergänzt stringR base R???



## Introduction

### Use of stringR in the R environment

StringR is a package, which deals with measuring strings, search in strings and also altering strings. StringR is thus mostly involved with data preprocessing, it can be also used to determine the frequency of words for example, which can be used in text mining.

////[!!!] Hier sollte man vll. besonders interessante Methoden kurz vorstellen wie str_detect, da man diese nicht nur zum Anpassen von Strings nutzen kann, sondern auch in den meisten Daten, die Strings enthalten.

### Types of data, which could be used with stringR

The use of stringR is dependent on which kind of data is available. If the data is a full text, that is e.g. the novel The Time Machine by H.G. Wells, then in text mining, you would tokenize that text (Silge Robinson 2017) and every word is put in another row, as you can see here:


```{r echo=FALSE}
#tm_text <- tibble(line = 1:4, text = tm_text)

tm_text %>%
  unnest_tokens(word, text)
```

This changes how you have to use stringR, because you don't deal with a full text now, which can be searched, but thousands of different boxes.

Another example is, if there is already just one word as an entry in every box, e.g. the job might be "cook". 

But there could also be several words in one box, e.g. the tags for a computer game: "singleplayer, action, medieval".



### Different string types
Es gibt ja verschiedene Textspeicherformate (encodings), wie: ASCII. Unicode
//[!!!]Können CSV Dateien bspw. überhaupt verschiedene string Speichermethoden haben?
//Sobald die Strings in R geladen werden und als character gelten, scheint ein einheitlicher String-Code vorzuliegen.

## Data Set for examples

As a data set for most of our examples we use the recipes data set, which contains recipes from various recipe websites from the USA. The dataset contains the recipe name, tags of the recipes such as vegetarian, the estimated time to cook it, the nutrition, the steps of the recipe itself and a decription of the recipe from the author. Also the ingredients are listed.


## Regular Expressions

Regular expressions are used mostly all programming languages and they are a way to normalize the syntax of strings. More importantly they can be used to express not a static word, but could also, more generally, define a group of words. For example, the set of words, which end on "r" contain the words "letter", "bear", "beer" etc.. So regular expressions are often used not to match a single word, but also a set of words.

//[!!!] Man könnte hier auch eine Funktion vorweg nehmen und dann anhand ein paar Wörter durchtesten, was matcht und was nicht love//w würde bspw. clover auch matchen, auch wenn man eigentlich nur alle Wörter mit love, lover, loved etc haben wollte. Hier müsste man ein paar Fallstricke auch mit einbauen.



## Functions of stringR explained




### Manage lengths

#### str_length

str_length(string) shows the number of characters (!not words)in the given argument string. This includes white spaces and also punctuation marks.

This could be used to compare the length of two strings, especially if they have to have the same length. This could also be used to determine the frequency of characters in a string.


<u>Example</u>

To show that punctuation marks and white spaces are also counted, we use here a simple example.

```{r , echo=TRUE}

str_length("Hello, world!")

```

#### str_pad

str_pad(string, width, side = c("left", "right",
"both"), pad = " ") adds as a default white spaces either to the left or right of a string. The width states how long the string should be after the adding of the white spaces. Both as a parameter for the side means that added white space is split between the left and the right side of the string. With the pad argument any other character can be added.

The idea seems to be to adjust strings of different length to the same length to match them in a subsequent step. E.g. when the comparison of the numbers 000247 with 247 should result in a match, we add 0s in front of the second number.


<u>Example</u>

In our dataset, the id consists sometimes of 5 or 6 digits, as you can see here:

```{r, echo=FALSE}

head(recipes$id,50)

```

We want to adjust all of the numbers to the same length. So we add a zero in front to those 5 digit numbers.

```{r, echo=FALSE}

head(str_pad(recipes$id, width = 6, side = "left", pad = "0"),50)

```

As we can see, some ids have now a 0 in front. These were 5 digit numbers before. 

This works also, if id is of numeric type in r, but the type is then changed to character.


#### str_trunc

str_trunc(string, width, side = c("right", "left",
"center"), ellipsis = "...") shortens the string to the given argument width. The side, on which the string is cut off is determined by the side argument.

<u>Example</u>

We could use the function to show more text from the description column than can be seen in the view(recipes) tab, to get a better impression, of what these texts are about. But we might not need the full text. We just want the first 100 characters, so we cut off to the right.

```{r, echo=TRUE}

head(str_trunc(recipes$description, width = 100, side = "right"),5)
recipes %>% mutate(description_short = str_trunc(description, width = 100, side = "right")) %>% select(name, description_short) %>% head()

```



#### str_trim

str_trim(string, side = c("both", "left", "right")) trims whitespaces from the start or end or both.

<u>Example</u>

```{r, echo=TRUE}

str_trim("     Hello, world!        ", side = "left")

```
As you can see, the whitespaces on the left are cut out, while the whitespaces on the right are still there.




//For str_trim keep in mind, that if you want to delete all the whitespaces, there are other methods. -> Welche?

//In base r this would be trimws






### Subset Strings


#### str_sub

str_sub(string, start=1L, end = -1L) can be used to extract substrings of a string. As a first parameter you give the text and as 2nd and 3rd parameter the start and end index of the substring are entered into the function. This can also be used to delete characters at the beginning and end of a string by extracting a version of the string without the beginning and end characters.


<u>Example</u>

In our data we have the nutrition given as a character string in the following format
```{r , echo=FALSE}
recipes$nutrition[1]
```
This whole term is a string, which we want to split into a list. First we have to delete the "[" in the beginning of the string and "]" at the end.

We can use the str_sub also to eliminate unwanted signs at the beginning and the end of a string.


```{r , echo=TRUE }
str_sub(recipes$nutrition[1], 2,str_length(recipes$nutrition[1])-1)

```
Then we can use the strsplit() function from base R to split the string into a list of strings.



#### str_subset

str_subset(string, pattern) gives back strings that contain a pattern match. That means the function needs a set of strings as an input into the first argument string here. A single string wouldn't make any sense. The function looks for all strings with the argument pattern in it and returns all the fitting strings as a (possibly) smaller set of strings.

<u>Example</u>

To give an example, we look at the description of a recipe, which looks like the following

```{r , echo=FALSE }
recipes$description[1]
```
Some of the descriptions contain the source of the recipe. So in this case, we want all the recipes, which originate from oregonlive.com

```{r , echo=TRUE }
str_subset(recipes$description, "oregonlive.com")

```
As you can see, the set of strings has been reduced just to two strings.


#### str_extract

str_extract(string, pattern) returns the first pattern match found in each string as a vector. 

If you simply give in a word as an argument for pattern, then the first match is either the word itself or the function gives NA out, if there is no match. If you give in a set of strings, the result is a vector with just the two aforementioned entries. Since this just gives the information, if a string contains a word or not, the str_detect function would be more suitable for the task.

The function can also be used with a vector of strings as an argument for pattern. Then the function gives back the first string of the vector, which has been found in the string of the first argument, which shall be searched.str_detect would just indicate that one of the strings in the vector is ture, but not which of them.


If you don't simply want the first match, then you can use also str.extract.all(). The output is a list of vectors (???).

<u>Example 1</u>

We look at the common words love and recipe in the description. In which decriptions does which come first or the pattern don't come up at all. 

```{r , echo=TRUE }
head(str_extract(recipes$description, "(love\\w|recipe\\w)"),100)

```
This example also shows, that you have to be careful with regular expressions. The 55rd entry "lovel" comes from lovely.


<u>Example 2</u>

One could also look at the ingredients and check, which recipes contain milk and eggs. Since we want to show that both are present in the dish or just one of these ingredients, we use str_extract_all

```{r , echo=TRUE }
head(str_extract_all(recipes$description, "onion"),5)


```

//Somehow this function doesn't work as advertised.No matches found, where there should be some. Is this because of the format of ingredients?

#### str_match

str_match(string, pattern) returns the first pattern match found in each string, as a matrix with a column for each () group in pattern.

This is based on groups from regular expressions. Strings can be grouped via brackets (). Everything within this bracket belongs to the same group. E.g. in the regex (a|b)(c|d) a and b belong to the same group. because they're in the same bracket.

In this function if a match of a is detected, this is a match for group 1 and thus "a" is put into column 2. The first column is always reserved for the whole expression. E.g. if the string "ac" is found, there will be an entry "ac" in the first column, "a" in the second column, because this is the letter matched for the first group. In the third column "c" will be matched, because "c" belongs to the second group.

As with str_extract, here also exists a str_match_all function to get all the matches and not just the first.


<u>Example 1</u>

Here we want to match the regular expression (love\\w|recipe\\w).+(beef). This means "love" and "recipe" form one group and beef forms the other. The whole expression as such is also a group.

```{r , echo=TRUE }
head(str_match(recipes$description, "(love\\w|recipe\\w).+(beef)"),5)

```

As you can see, in the first column there is the entry beloging to the whole regular expression as a group. The string contains "love" as well as "beef". In the second column, the string matched from the first group is "love", in the third column "beef".

<u>Example 2</u>

//One could also let the date be strings and then match all dates from 2005, 2006, in the first 6 months, in the first half of the month.

//"(2005|2006)[.-](11|12)[.-](17|18)


```{r , echo=TRUE }
head(str_match(recipes$submitted, "(2005|2006)[.-]([1-6])[.-]([1-15])"),5)

```

//[!!!]Unfortunately this doesn't work


### Detect matches

#### str_detect

str_detect(string, pattern) detects the presence of a pattern match in a string. The result is simply TRUE and FALSE

<u>Example</u>

Here we search for love and recipe in the description of every recipe. 

```{r , echo=TRUE }
head(str_detect(recipes$description, "(love\\w|recipe\\w)"),100)

```
In contrast to extract, we just see, that one of the strings is in a certain string or not, but not which one of those.

#### str_which

str_which(string, pattern) finds the indices of strings that contain a pattern match. The output is a vector with these indices.



<u>Example</u>

Again we search for "love" and "recipe" in the description column.

```{r , echo=TRUE }
head(str_which(recipes$description, "(love\\w|recipe\\w)"),100)

```

#### str_count

str_count(string, pattern) counts the number of matches in a string.

<u>Example</u>

"i" occurs very often in the descriptions of the recipes. Let's see how often per description. As a regular expression we have chosen " i ", that is an i sourrounded by white spaces. This means in sentences like "I ...." the i is not matched.

```{r , echo=TRUE }
head(str_count(recipes$description, " i "),100)

```

#### str_locate

str_locate(string, pattern) locates the positions of the first pattern match within a string.

```{r , echo=TRUE }
head(str_locate(recipes$description, " i "),10)

```
If you look up the first description string

```{r , echo=FALSE }
recipes$description[1]

```
Then you can see, that the first " i " is indeed from position 22 to 24. The length of 3 come from 2 whitespaces and the i.


### Mutate Strings

In this part we will use Italy, a subset of "recipes" that is exclusively containing recipes mentioning "pizza".
``` {r, echo=FALSE}
Italy <- recipes %>% filter(stringr::str_detect(name, "pizza"))
```

#### str_replace (and replace_all) 

```{r, echo=FALSE}
Italy <- Italy %>% 
  mutate(name1 = str_replace(Italy$name, "pizza", "fluffy pizza"))
```

The replace functions of stringr are used to match patterns and replace them with new strings. 
Example: For seo (search engine optimization) we will add the popular word "fluffy" to all our pizza recipes in the name column.  
In order to replace several matches use str_replace_all and create a vektor containing multiple coditions.

``` {r, echo=FALSE}
Italy <- Italy %>% 
  mutate(name2 = str_replace_all(Italy$name, c("pizza" = "fluffy pizza", "easy" = "easy peasy")))
```

##### str_to_lower

We can use str_to_ to change the case of text strings. They are intutitive: 
str_to_lower will change text to lower case, 
str_to_upper will change text to upper case,
str_to_title will change first letter of a string into a capital letter.
... 
``` {r, echo=FALSE}
p <- c("i","like","pizza","and","i don't share pizzza")
str_to_upper(p)
str_to_sentence(p)
p <- str_c(p, collapse = " ") #make it one sentence (see str_c)
str_to_sentence(p)
```

Attention: Locales will apply language conventions when changing the case. As you know, capitalization is used different in German and English. Above, the default would be locale = "en" but you can change it into every other language. The code for your langugage can be found in Wikipedia - List of ISO 639-1 codes.

Locales also come in handy for the str_order or str_sort fuction. 
str_sort will sort a list of string vectors by alphabet (locale will determine wich alphabet is applied)

```{r, echo=FALSE}
str_sort(Italy$name1[1:10], decreasing = FALSE, na_last = TRUE, locale = "en", numeric = FALSE)
```

### Join and Split

#### str_c

If you want to merge several strings into one, the str_c funtion is what you need. It is simple: either you join two or more single strings using the seperate argument to choose a separation sign or you join a vector of strings by having the argument collapse control how the strings are separeted. 
In our Pizza example you can first see the join of the first few names into one string separated by ", " and then a vector that is joint into one string unsig the words "and then" as a form of separation. 

```{r, echo=FALSE}
str_c(Italy$name2[1],Italy$name2[2], Italy$name2[3], sep = ", ")
str_c(Italy$name2[1:3], collapse = " and then ")
```

#### str_split

The str_split function will split a vector of strings into a list of substrings. The split is made where there is a match with a pattern of your choice.
In our exapmle we will split the cloumn step containing step by step instructions into single substrings. As the steps currently have the format of a list, we can use the comma as a pattern to seperate the strings. 

```{r, echo=FALSE}
Italy$steps %>% str_split("', '") %>% head(2)

```
If you'd rather have the subset of strings in a matrix, you can use str_split_fixed and choose n for the number of columns in the matrix. 

#### str_glue

```{r, echo=FALSE}
pandas <- c("Carl","Jakob","Jakob","Markus","Robert")
str_glue("Hey {pandas}! I'd recommend the recipe '{str_to_title(Italy$name2[1:5])}' for you." )

```

As you can see, str_glue literally glues strings together to create a new string. Expressions must be written in {} but everything else is up to you: you can use data frames, listes and regex. Useful for customized mailing, ditribution of tasks ect. 



## Literature

Silge, J., & Robinson, D. (2017). Text mining with R: A tidy approach. " O'Reilly Media, Inc.".
